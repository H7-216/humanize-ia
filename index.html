<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Slope 3D Mockup</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin:0; background:#000; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W, H, cx, cy;

  function resize(){
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2 + 100;
  }
  window.addEventListener('resize', resize);
  resize();

  // Paramètres
  const focalLength = 300;
  let speed = 0;
  let acceleration = 0.0005;
  let playerX = 0;
  let maxX = 200;
  let platforms = [];
  const platformCount = 200;

  // Création initiale des plateformes
  for(let i=0; i<platformCount; i++){
    platforms.push({
      x: (Math.random()*2 -1) * maxX,
      z: i * 20,
      gap: Math.random() < 0.1, // trou
      obstacle: Math.random() < 0.08
    });
  }

  // Contrôles
  const keys = {};
  window.addEventListener('keydown', e=>keys[e.key]=1);
  window.addEventListener('keyup', e=>keys[e.key]=0);

  // Collision detection basique
  function checkCollision(){
    for(let p of platforms){
      if(p.z < speed+10 && p.z > speed-10){
        const scale = focalLength / (p.z - speed + focalLength);
        const px = cx + p.x * scale;
        const pw = maxX * scale;
        if(!p.gap){
          if(playerX*scale > p.x*scale - pw && playerX*scale < p.x*scale + pw){
            if(p.obstacle){
              // touche obstacle
              return true;
            }
            return false;
          }
        }
        return true; // tombe dans le trou
      }
    }
    return false;
  }

  // Boucle
  function loop(ts){
    ctx.clearRect(0,0,W,H);
    speed += acceleration * ts;
    if(keys['ArrowLeft']) playerX -= 0.3 * ts;
    if(keys['ArrowRight']) playerX += 0.3 * ts;
    playerX = Math.max(-maxX, Math.min(maxX, playerX));

    // Dessin plateformes
    platforms.forEach(p=>{
      const dz = p.z - speed;
      if(dz < 1) return;
      const scale = focalLength / dz;
      const px = cx + p.x * scale;
      const py = cy + dz * scale;
      const pw = maxX * scale;
      const ph = 10 * scale;
      if(dz > 0){
        ctx.fillStyle = p.obstacle ? '#f00' : (p.gap ? '#333' : '#444');
        ctx.fillRect(px - pw, py, pw*2, ph);
      }
    });

    // Dessin balle
    const ballZ = 10;
    const ballScale = focalLength / (ballZ);
    const ballX2 = cx + playerX * ballScale;
    const ballY2 = cy + ballZ * ballScale;
    const ballR = 15 * ballScale;
    ctx.beginPath();
    ctx.arc(ballX2, ballY2, ballR, 0, 2*Math.PI);
    ctx.fillStyle = '#0f0';
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 10;
    ctx.fill();

    // Vérifier collision ou chute
    if(checkCollision()){
      return gameOver();
    }

    requestAnimationFrame(loop);
  }

  function gameOver(){
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '30px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', cx, cy);
    // reload après 2s
    setTimeout(()=>location.reload(), 2000);
  }

  requestAnimationFrame(loop);
  </script>
</body>
</html>