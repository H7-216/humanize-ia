<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Slope 3D - Version Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
  let scene, camera, renderer, ball, track = [], speed = 0.2, maxLanes = 5;
  let trackSegments = 100, segmentLength = 20, lanes = [-4, -2, 0, 2, 4];
  let obstacles = [];
  let clock = new THREE.Clock();

  init();
  animate();

  function init() {
    // Sc√®ne et cam√©ra
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    // Lumi√®re
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(0, 10, 10);
    scene.add(light);

    // Renderer
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Sol de base
    const trackMat = new THREE.MeshPhongMaterial({color: 0x111111});
    for (let i = 0; i < trackSegments; i++) {
      const trackPart = new THREE.Mesh(
        new THREE.BoxGeometry(10, 0.5, segmentLength),
        trackMat
      );
      trackPart.position.z = -i * segmentLength;
      track.push(trackPart);
      scene.add(trackPart);
    }

    // Balle
    const ballGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x00ff00});
    ball = new THREE.Mesh(ballGeo, ballMat);
    ball.position.y = 1;
    scene.add(ball);

    // Obstacles initiaux
    for (let i = 10; i < trackSegments; i += 5) {
      spawnObstacle(-i * segmentLength);
    }

    // √âv√©nements clavier
    document.addEventListener("keydown", onKeyDown);
    window.addEventListener('resize', onResize);
  }

  function spawnObstacle(z) {
    const lane = lanes[Math.floor(Math.random() * lanes.length)];
    const obstacle = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xff0000})
    );
    obstacle.position.set(lane, 0.75, z);
    scene.add(obstacle);
    obstacles.push(obstacle);
  }

  function onKeyDown(e) {
    if (e.key === "ArrowLeft" || e.key === "a") {
      ball.position.x -= 2;
      if (ball.position.x < -4) ball.position.x = -4;
    }
    if (e.key === "ArrowRight" || e.key === "d") {
      ball.position.x += 2;
      if (ball.position.x > 4) ball.position.x = 4;
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    // Bouger la piste
    for (let part of track) {
      part.position.z += speed;
      if (part.position.z > 10) {
        part.position.z -= trackSegments * segmentLength;
      }
    }

    // Bouger les obstacles
    for (let o of obstacles) {
      o.position.z += speed;
      if (o.position.z > 10) {
        o.position.z = -trackSegments * segmentLength;
        o.position.x = lanes[Math.floor(Math.random() * lanes.length)];
      }
    }

    // Collision
    for (let o of obstacles) {
      if (Math.abs(ball.position.z - o.position.z) < 1 &&
          Math.abs(ball.position.x - o.position.x) < 1) {
        alert("üí• Game Over !");
        window.location.reload();
      }
    }

    // Avancer la balle (visuellement le monde recule)
    ball.position.z += speed;

    // Cam√©ra suit la balle
    camera.position.z = ball.position.z + 10;
    camera.lookAt(ball.position.x, ball.position.y, ball.position.z);

    // Augmenter la vitesse lentement
    speed += 0.0002;

    renderer.render(scene, camera);
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
</script>
</body>
</html>